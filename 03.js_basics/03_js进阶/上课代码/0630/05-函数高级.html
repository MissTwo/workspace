<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    // 定义了函数t1，带有形参a
    function t1(a, b) {
        console.log(a)
        console.log(arguments)
        console.log(new.target) // 只有new调用函数的时候才有值，值就是该函数的本身
        console.log(new.target.length, new.target.arguments.length, new.target.caller, new.target.name);
    }
    // t1(1, 2) // 调用了t1函数，并传了实参1
    // 分析对象的结构
    console.dir(t1)
    console.log(t1.name)
    console.log(t1.length)
    console.log(t1.caller)
    console.log(t1.arguments)

    new t1()

    function outer() {
        inner();
    }
    function inner() {
        console.log(inner.caller);
    }
    outer();

    function t2() {
        //如何实现一个函数必须通过new 来调用，否则抛出异常
        if (!new.target) {
            throw new Error("t2 必须通过new来调用");
        }
    }
    // t2()
    // new t2()
    // Map()

    // 函数的三个高级方法
    /*
        apply(this对象, 实参数组)：修改函数对象的this指向，同时也可以传参，参数必须是数组，最后调用函数
        call(this对象，可变参数)：修改函数对象的this指向，同时也可以传参，参数需要展开，最后调用函数
        bind(this对象，可变参数)：修改函数对象的this指向，同时也可以传参，参数需要展开，返回处理之后函数对象
     */
    function t3(a, b, c) {
        console.log(this);
        console.log(this.name)
        console.log(a, b, c)
    }
    t3() // window
    let obj = {name: "张三"};
    // 调用函数，比t3()这种方式多了一个修改this指向的能力
    t3.apply(obj, [1, 3, 5]) // obj
    t3.call(obj, 1, 3, 5)
    // t3.call(obj, [1, 3, 5])
    let t4 = t3.bind(obj, 2, 3, 5) // 不会调用函数
    t4()
    // t3();
    console.log("--------------------------------")
    function test(a,b,c,d) {
        console.log(a,b,c,d)
    }
    let obj2={
        name: "张三",
    }
    console.log("--------------------------------")
    console.log("函数直接调用", test(1, 2, 3, 4));
    // 修改函数的this指向
    test.apply(obj2,[1,3,5,7])
    console.log("使用apply调用函数",obj2)
    test.call(obj2, 2, 4, 6, 8, 10);
    console.log("call",obj2)

    test.bind(obj2,11,22,33,44)();
    console.log("bind",obj2)

</script>
</body>
</html>