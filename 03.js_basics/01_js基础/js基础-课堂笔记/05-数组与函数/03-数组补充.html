<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>


  <script>
    /* 
    字符串 = 数组.toString(); //只能逗号分割 参数无效
    字符串 = String(数组); //只能逗号分割
    字符串 = 数组.join(',');
    */
    // let arr1 = ["a" , "b", "c" , "d" , "e"];
    // let arr2 = ["f" , "g"];
    // let arr3 = ["h"];
    // let newArr = arr1.concat(arr2 , arr3 , [1 , 2 , 3]);



    // --------------------------------------------------------------
    //数组的sort()方法
    /* 
    用于对原数组进行排序，改变原数组，不会产生新数组，这个方法的参数又是一个函数

    sort()方法不是按照数字大小来排序的，默认不加参数时，是按照字典（元素的字符编码，Unicode 编码）顺序排序。数值会被先转成字符串，再按照字典（元素的字符编码）顺序进行比较，排序后
    */

    // let arr=['e','b','d','a','f','c'];
    // let arr = [5, 2, 11, 3, 4, 1];
    // arr.sort();
    // console.log(arr);

    //我们可以通过设置参数实现自定义排序规则 
    /* 
    sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。

    浏览器根据**回调函数的返回值return来决定元素的排序**：（重要）
    -   如果返回一个大于 0 的值，则元素会交换位置
    -   **如果返回一个小于 0 的值，则元素位置不变**
    -   如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置


    */
    // let arr = [5, 2, 11, 3, 4, 1];

    // 写法1：
    // arr.sort(function (a, b) {
    //   if(a>b){
    //     return 1;
    //   }else if(a<b){
    //     return -1
    //   }else{
    //     return 0;
    //   }
    // });

    //写法2：//升序
    // arr.sort(function(a,b){return a-b;})
    //降序
    // arr.sort(function(a,b){return b-a;})
    //反序
    // arr.sort(function(a,b){return -1;})
    //正序
    // arr.sort(function(a,b){return 1;})
    // console.log(arr);

    //**随机排序**  return一个 [-0.5,0.5] 正值负值几率各占一半
    // let arr = [5, 2, 11, 3, 4, 1];
    // arr.sort(function(a , b){  return Math.random() - 0.5;  }) 
    // console.log(arr);

    //将数组从小到大/从大到小排序是开发中非常常见的需求，但实际开发中总是花样比较多
    //如： 按照publishTime数值大小进行升序
    // let dataList = [{
    //     title: "品牌鞋子，高品质低价入手",
    //     publishTime: 200,
    //   },
    //   {
    //     title: "不是很贵，但是很暖",
    //     publishTime: 100,
    //   },
    //   {
    //     title: "好吃",
    //     publishTime: 300,
    //   },
    // ];
    // dataList.sort(function (a, b) {//a和b代表数组中靠前的项和靠后的项
    //   return a.publishTime - b.publishTime;
    // })
    // console.log("排序后的数组", dataList);


    // 冒泡排序 
    /* 
    数组中有n个数，比较每相邻两个数，如果前者大于后者，就把两个数交换位置;这样一来，第一轮就可以选出一个最大的数放在最后面;那么经过n-1(数组的length -1）趟，就完成了所有数的排序
    4个数字，共需要比较3趟，比较次数为3+2+1=6次。
    n个数字，共需要比较n-1趟，比较次数为n(n-1)/2次。
    */

    //我们先来实现找数组中的最大数，并把他放到数组最后。
    // let arr = [1, 7, 8, 3, 2,0];
    //这里写小于arr.length同样可以实现需求，但是最后一次循环是没有必要的，所以将它减掉
    // for(let i=0; i<arr.length-1; i++){
    //   if(arr[i+1]<arr[i]){
    //     let temp=arr[i];
    //     arr[i]=arr[i+1];
    //     arr[i+1]=temp;
    //   }
    //   console.log(arr);
    // }

    //两两比较实现升序 
    // let arr = [1, 7, 8, 3, 2, 0];
    // //1、外层 for 循环控制循环次数  2、内层 for 循环进行两数交换，找每次的最大数，排到最后
    // for(let i=0; i < arr.length-1; i++){ 
    //   //虽然j < arr.length-1可以实现需求 但是有多次重复无必要的循环比较 最好优化一下
    //   for(let j=0; j < arr.length-1-i; j++){
    //     if(arr[j+1]<arr[j]){
    //       let temp=arr[j];
    //       arr[j]=arr[j+1];
    //       arr[j+1]=temp;
    //     }
    //     // 每一次两两比较
    //     console.log(arr);
    //   }
    //   //每一趟比较后的输出 每一趟确定一个本轮最大的数放到后面去
    //   // console.log(arr);
    // }
    // console.log(arr);


    //----------------------------------------------------------
    //reverse();置反
    // let arr = [5, 2, 11, 3, 4, 1];
    // let newArr = [];
    // for (let i = 0; i < arr.length; i++) {
    //   newArr[i] = arr[arr.length - 1 - i];
    // }

    // for (var i = arr.length - 1; i >= 0; i--) {
    //   // console.log(arr[i])
    //   newArr[newArr.length] = arr[i]
    // }
    // console.log(newArr);

    //-------------------------------------------------------------------

    /* 
    遍历数组的方法还包括：every()、filter()、forEach()、map()等。高阶函数
    */
    //forEach()   这种遍历方法**只支持 IE8 以上的浏览器**。IE8 及以下的浏览器均不支持该方法。所以如果需要兼容 IE8，则不要使用 forEach，改为使用 for 循环来遍历即可。
    /* 
    forEach()方法需要一个函数作为参数，我们称为**回调函数。**数组中有几个元素，该回调函数就会执行几次, 基本数据类型下不会改变原数组
    回调函数中**传递三个参数：**
    第一个参数：当前正在遍历的元素
    第二个参数：当前正在遍历的元素的索引（下标）
    第三个参数：正在遍历的数组,一般不需要使用到
    */
    // let arr = ["老曾" , "黛玉" , "宝钗"];
    // let arr1=arr.forEach(function(item,index,arr){
    //   console.log(item,index,arr);
    // })
    // let arr1=[];
    // let arr2=arr.forEach(function(item,index){
    //   item="张三";
    //   arr1.push(item);
    // })
    // // console.log(arr2);//undefined
    // console.log(arr1);//



    //**`forEach`方法不返回值**，只用来操作数据,如果数组遍历的目的是**为了改变数据得到返回值**，那么**使用`map`方法**，否则使用`forEach`方法。

    //`map`方法与`forEach`方法很相似，也是对数组的所有成员依次执行参数函数。同样：回调函数接收三个参数：当前成员，当前成员的下标，当前遍历的数组
    //`map`方法将数组的所有成员**依次执行参数函数**，然后把每一次的执行结果**组成一个新数组返回**。不会改变原数组。
    // let arr = [12, 23, 24, 42, 1];
    // let arr1 = arr.map(function (item, index, arr) {
    //   return item * 10;
    // });
    // console.log(arr1);
    // console.log(arr1 == arr); //false

    // arr1中的name属性 存储到数组arr2中 使用map();
    // let arr1 = [{
    //     name: "李四",
    //     age: "18"
    //   },
    //   {
    //     name: "张三",
    //     age: "16"
    //   }
    // ];
    // let arr2=arr1.map(function(item){
    //   return item.name;
    // })
    // console.log(arr2);//['李四', '张三']

    //将数组 arr1 中的 name、age这两个属性，改一下“键”的名字myName,myAge，存储到 arr3中
    // let arr3 = arr1.map(function(item){
    //   return {
    //     myName:item.name,
    //     myAge:item.age
    //   };
    // })
    // console.log(arr3);
    // [{
    //     myName: "李四",
    //     myAge: "18"
    //   },
    //   {
    //     myName: "张三",
    //     myAge: "16"
    //   }
    // ]
    //map()的应用场景基本上就是以上两种

    //-------------------------------------------------------------------
    //filter();  用于过滤数组成员，他的参数是一个函数,这个函数接收三个参数，当前成员，当前成员的索引，当前数组
    //对数组中的每一项运行回调函数**返回结果为`true`的成员组成一个新数组返回**,**不会改变原数组**。

    // let arr = [1 , 3 , 4, 6, 8, 28 ];
    // let arr1 = arr.filter(function(item,index,arr){
    //   return true;
    // })
    // console.log(arr1);//[1 , 3 , 4, 6, 8, 28 ]

    //寻找所有偶数放入到一个新数组中
    // let arr1 = arr.filter(function(item){
    //   return item%2==0;
    // })
    // console.log(arr1);//[1 , 3 , 4, 6, 8, 28 ]

    //找出数组 arr 中大于 4 的元素，返回一个新的数组。
    // let arr1 = arr.filter(function(item){
    //   if(item>4){
    //     return true;
    //   }else{
    //     return false;
    //   }

    //   //简写 return (item>4);
    // })
    // console.log(arr1);

    //筛选出一线歌手 （仅做随机展示不代表本人最终观点）
    // let arr = [{
    //     name: "许嵩",
    //     type: "一线"
    //   },
    //   {
    //     name: "周杰伦",
    //     type: "过气"
    //   },
    //   {
    //     name: "邓紫棋",
    //     type: "一线"
    //   }
    // ];
    // let arr1=arr.filter(function(item){
    //   return (item.type=="一线");
    // })
    // console.log(arr1);


    //-----------------------------------------------------------------
    //every(); 返回值是一个布尔值，参数是一个函数，对数组中每一项运行回调函数，如果都返回true,every()方法就返回true,如果有一个返回false，则停止遍历，最终返回false，一般用于检测是否全部复合规则
    // let arr = ["千古", "宿敌", "南山忆", "素颜"];
    // // let bool1=arr.every(function(item,index,arr){
    // //   return true;
    // // })
    // // console.log(bool1);//true

    // let bool1 = arr.every(function(item){
    //   if(item.length>2){
    //     return false;
    //   }else{
    //     return true;
    //   }
    // })
    // console.log(bool1); //false


    //some(); 返回值是一个布尔值，参数是一个函数，对数组中每一个元素运行这个回调函数，只要有一个返回true，则停止遍历 此some()方法返回true。
    // let arr = ["千古", "宿敌", "南山忆", "素颜"];
    // let bool1 = arr.some(function (item) {
    //   if (item.length > 2) {
    //     return true;
    //   } else {
    //     return false;
    //   }
    // })
    // console.log(bool1); //true

    /* 
    every()：**全部真，才为真**。当你需要让数组中的每一个元素都满足指定条件时，那就使用 every()。

    some()：**一个真，则为真**，点到为止。数组中只要有一个元素满足指定条件时，就停止遍历。那就使用 some()。
    */

    //--------------------------------------------------------------
    //find(); 找出第一个满足（指定条件返回true）的元素，返回的是这个元素，而不是下标，如果没有找到，返回undefined
    //一旦找到就停止遍历不在往下找
    // let arr = ["千古", "宿敌", "南山忆", "素颜"];
    // let arr1=arr.find(function(item,index,arr){
    //   return item.length > 2;
    // })
    // console.log(arr1);//南山忆


    //findIndex();  找出第一个满足指定条件的元素的（下标），一旦找到第一个就不会在往下找
    // let arr = ["千古", "宿敌", "南山忆", "素颜"];
    // let arr1=arr.findIndex(function(item,index,arr){
    //   return item.length > 2;
    // })
    // console.log(arr1);//2 下标

    //应用：
    // let students = [{
    //     name: "老曾",
    //     sex: "男",
    //     age: 18
    //   },
    //   {
    //     name: "李四",
    //     sex: "男",
    //     age: 16,
    //   },
    //   {
    //     name: "张三",
    //     sex: "女",
    //     age: 56,
    //   }
    // ];
    //找出第一个性别为女的元素，找出第一个性别为男的元素的下标
    //找出所有已成年的人员的名字 

    //-----------------------------------------------------------
    //reduce();方法
    /* 
    接收一个函数作为参数（累加器），数组中每个值（从左到右）开始缩减，最终计算为一个值，reduce()的返回值就是回调函数累计处理的结果

    语法：
    arr.reduce(function (previousValue, currentValue, currentIndex, arr) {
    ...
    }, initialValue);
    //参数解释：
    //previousValue：必填，上一次调用回调函数时的返回值，在initialValue未指定时，第一次的prev的值是数组的第一个值

    //currentValue：必填，当前正在处理的数组元素

    //currentIndex：选填，当前正在处理的数组元素下标

    //arr：选填，调用 reduce()方法的数组

    //initialValue：选填，指定的初始值（作为第一次调用回调函数时传给 previousValue 的值）默认0
    */
    // let arr = ["老曾", "张三","王二麻子"];
    // arr.reduce(function(pre,item){
    //   console.log(pre);
    //   console.log(item);
    //   return 88;
    // },0)
    //0 老曾
    //88 张三
    //88 王二麻子
    //上面的代码中，由于return的是固定值，所以 prev 打印的也是固定值（只有初始值是 0，剩下的遍历中，都是打印 88）。

    // 不传递参数initialValue的时候 index是从1开始的(循环直接跳过第一轮)，第一个prev的值是数组的第一个元素
    // let arr = ["老曾", "张三","王二麻子","李四"];
    // arr.reduce(function(pre,item,index){
    //   console.log(pre,item,index);//老曾 张三 1  88 "王二麻子" 2
    //   return 88;
    // })
    //老曾 张三 1  88 "王二麻子" 2

    //举例： 计算数组中所有元素的总和  和  乘积 （使用reduce）
    // let arr = [1, 2, 3, 4];
    // let sum = arr.reduce(function(prev,item){
    //   return prev+item; //6+4=10
    // })
    // console.log(sum);

    // let sum2=arr.reduce(function(prev,item){
    //   return prev*item; 
    // })
    // console.log(sum2);

    // let arr1 = [1, 2, 6, 5, 6, 1, 6];
    // //统计数组中某个元素出现的次数。 6（使用reduce） 封装成一个函数
    // // function repeatCount(arr, value){...} arr传入的数组，value想要检测的元素 函数执行输出次数
    // function repeatCount(arr, value){
    //   return arr.reduce(function(count,item){
    //     count += (item == value ? 1 : 0);
    //     return count;
    //   },0)
    // }
    // console.log(repeatCount(arr1, 6));

    //求arr中元素的最大值（使用reduce）
    // let arr = [2, 0, 1, 9, 6];
    // let maxValue = arr.reduce(function(prev,item){
    //   return prev > item ? prev : item;
    // })
    // console.log(maxValue); //9


    // 计算数组中每个元素出现的次数    obj={2: 2, 3: 1, 4: 1, 10: 3}
    // xx in obj 检测obj中是否有xx属性名
    let arr = [10, 2, 3, 4, 2, 10, 10];
    let obj = arr.reduce(function(prev,item){
      
    });
    console.log(obj);//{2: 2, 3: 1, 4: 1, 10: 3}




    

  </script>
</body>

</html>